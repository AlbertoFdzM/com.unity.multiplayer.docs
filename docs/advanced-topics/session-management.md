---
id: session-management
title: Session Management
---
In a multiplayer game, we might want to have some session management to allow players to correctly reconnect to the game. What this exactly means might vary depending on the game, but the core idea is that there is some data that needs to be kept when a player disconnects, and assigned back to them when they reconnect. We must also make sure that the data is reassigned to the right player.

## Linking data to players
To reassign data to the right player when they reconnect, we need a way to link this data to the player. The clientId generated by NGO cannot be used, however, since it is generated when a player connects and is disposed of when they disconnect. It can then be assigned to a different player when if they connect to the server after the first one disconnected. To properly link data to a specific player, we need an ID that is not tied to the current session, that persists through time, and that is unique to that player. A few solutions can be used, such as a login system with unique player accounts, or simply a Globally Unique Identifier (GUID). A GUID can be generated via `System.Guid.NewGuid()` and then saved to the `PlayerPrefs`, for example.

When we have such a way to uniquely identify a player, we can then use it to map each player's data that would be needed when reconnecting, such as the current state of their character for example. Then, we need to make sure this data is up to date and to keep it after a player disconnects. We could add a timeout after which we can purge the data or we could decide to clear all data only when a session completes. And finally, once we have up to date data that we can link to a specific player who disconnected earlier, we can now handle reconnection properly.

## Handling reconnection
In cases where we use a Player Object, a new Default Player Prefab will be automatically spawned when any player connects to the game (including if they are reconnecting). We can then use the player's data to update that object so that its state returns to what it was before disconnecting. In those cases, we would need to keep all the important data that we want to restore and map it to the player using our identification system.

In cases where we use the ownership model, we could instead keep the objects that a player owns when they disconnects, and set the reconnected player as their new owner. To accomplish this, the only data we would need to keep would be the mapping between those objects and their owning player's identifier, then when a player reconnects we could use this mapping to set them as the new owner.

## Example using the Player Object model
Here is an example from the Boss Room sample, showing some simple session management. The game uses the Player Object model and a GUID to identify unique players. In that example, each player's data is saved in the `m_ClientData` dictionary, and each of their clientId is mapped to their Guid in `m_ClientIDToGuid`. The saved data is represented by the struct `SessionPlayerData`, which includes a character's name, their class, their position and their current hit points, as well as flags informing wether the player is connected or not, and if their character has been spawned. The former is used in the `OnClientApprovalCheck` method to differentiate between a duplicate connection and a reconnection, while the latter is used by other scripts to decide whether to initialize data or to set it to the values saved here.

When a player is connecting, their session data is created in the `OnClientApprovalCheck` method, which in this case is called by another script as part of `NetworkManager`'s `ConnectionApprovalCallback`. It is also in this method that we verify if data already exists for this GUID, and if so, check wether it is a duplicate login or a reconnection. In the case of a reconnection, we simply update the mapping of the player's GUID to their new client id. This data can then be accessed via the `GetPlayerData` method, from wherever it is needed. This data is updated via the `SetPlayerData` method.

Finally, when a player disconnects, `OnClientDisconnect` is called, which updates the `IsConnected` flag. When the game is over, `OnGameEnded` clears all the data from players who disconnected but did not reconnect, so that if a new game is started, a reconnecting player would be treated as a new player, as intended. The rest of the data stays saved until the server is shut down.

```csharp reference
https://github.com/Unity-Technologies/com.unity.multiplayer.samples.coop/blob/develop/Assets/BossRoom/Scripts/Shared/Net/ConnectionManagement/SessionManager.cs
```